// SPDX-License-Identifier: Apache-2.0

package chiseltest.simulator

import firrtl.{AnnotationSeq, CircuitState}
import firrtl.annotations.NoTargetAnnotation
import firrtl.options._
import chiseltest.internal.Compiler
import chiseltest.simulator.ipc.{IPCSimulatorContext, VpiVerilogHarnessGenerator}

case object VcsBackendAnnotation extends SimulatorAnnotation with HasShellOptions {
  override def getSimulator: Simulator = {
    throw new NotImplementedError("No VCS support yet!")
  }

  val options: Seq[ShellOption[_]] = Seq(
    new ShellOption[Unit](
      longOption = "t-use-vcs",
      toAnnotationSeq = _ => Seq(VerilatorBackendAnnotation),
      helpText = "direct tester to use VCS backend"
    )
  )
}

/** VCS specific options */
trait VcsOption extends NoTargetAnnotation

/** adds flags to the invocation of VCS */
case class VcsFlags(flags: Seq[String]) extends VcsOption

/** adds flags to the C++ compiler in the Makefile generated by Vcs */
case class VcsCFlags(flags: Seq[String]) extends VcsOption

object VcsSimulator extends Simulator {
  override def name: String = "vcs"

  /** is this simulator installed on the local machine? */
  override def isAvailable: Boolean = {
    firrtl.FileUtils.isVCSAvailable
  }

  /** search the local computer for an installation of this simulator and print versions */
  override def findVersions: Unit = {
    ??? // TODO
  }

  /** start a new simulation
    *
    * @param state LoFirrtl circuit + annotations
    */
  override def createContext(state: CircuitState): SimulatorContext = {
    // we will create the simulation in the target directory
    val targetDir = Compiler.requireTargetDir(state.annotations)
    val toplevel = TopmoduleInfo(state.circuit)

    // Create the VPI files that vcs needs + a custom harness
    val waveformExt = Simulator.getWavformFormat(state.annotations)
    val verilogHarness = generateHarness(targetDir, toplevel, waveformExt)

    // compile low firrtl to System Verilog for verilator to use
    val verilogState = Compiler.lowFirrtlToSystemVerilog(state, VerilatorCoverage.CoveragePasses)

    // turn SystemVerilog into simulation binary
    val simBin = compileSimulation(toplevel.name, targetDir, verilogHarness, state.annotations)

    // the binary we created communicates using our standard IPC interface
    val coverageAnnos = VerilatorCoverage.collectCoverageAnnotations(verilogState.annotations)
    new IPCSimulatorContext(simBin, toplevel, coverageAnnos, VerilatorSimulator)
  }

  /** executes VCS in order to generate a simulation binary */
  private def compileSimulation(
    topName:        String,
    targetDir:      os.Path,
    verilogHarness: String,
    annos:          AnnotationSeq
  ): os.Path = {
    val flags = generateFlags(topName, targetDir, annos)
    val cmd = List("vcs") ++ flags ++ List("-o", topName, s"$topName.sv", verilogHarness, "vpi.cpp")
    val ret = os.proc(cmd).call(cwd = targetDir)

    assert(ret.exitCode == 0, s"vcs command failed on circuit ${topName} in work dir $targetDir")
    val simBinary = targetDir / topName
    assert(os.exists(simBinary), s"Failed to generate simulation binary: $simBinary")
    simBinary
  }

  private def generateFlags(topName: String, targetDir: os.Path, annos: AnnotationSeq): Seq[String] = {
    // generate C flags
    val userCFlags = annos.collectFirst { case VcsCFlags(f) => f }.getOrElse(Seq.empty)
    val cFlags = DefaultCFlags(targetDir) ++ userCFlags

    // combine all flags
    val userFlags = annos.collectFirst { case VcsCFlags(f) => f }.getOrElse(Seq.empty)
    val flags = DefaultFlags(topName, cFlags) ++ userFlags
    flags
  }

  private def DefaultCFlags(targetDir: os.Path) = List(
    "-I$VCS_HOME/include",
    s"-I$targetDir", // TODO: is this actually necessary?
    "-fPIC",
    "-std=c++11"
  )

  private def DefaultFlags(topName: String, cFlags: Seq[String]) = List(
    "-full64",
    "-quiet",
    "-timescale=1ns/1ps",
    "-debug_pp",
    s"-Mdir=$topName.csrc",
    "+v2k",
    "+vpi",
    "+vcs+lic+wait",
    "+vcs+initreg+random",
    "+define+CLOCK_PERIOD=1",
    "-P",
    "vpi.tab",
    "-cpp",
    "g++",
    "-O2",
    "-LDFLAGS",
    "-lstdc++",
    "-CFLAGS",
    "\"" + cFlags.mkString(" ") + "\""
  )

  private def generateHarness(targetDir: os.Path, toplevel: TopmoduleInfo, waveformExt: String): String = {
    val topName = toplevel.name

    // copy the VPI files + generate a custom verilog harness
    CopyVpiFiles(targetDir)
    val verilogHarnessFileName = s"${topName}-harness.sv"
    val vcdFile = targetDir / (s"$topName." + waveformExt)
    val emittedStuff = VpiVerilogHarnessGenerator.codeGen(toplevel, vcdFile, isGateLevel = false)

    os.write.over(targetDir / verilogHarnessFileName, emittedStuff)

    verilogHarnessFileName
  }
}

/** Copies the files needed for the VPI based simulator interface.
  */
object CopyVpiFiles {
  def apply(destinationDirPath: os.Path): Unit = {
    val files = Seq("sim_api.h", "vpi.h", "vpi.cpp", "vpi.tab")
    val resourcePrefix = "/simulator/"

    files.foreach { name =>
      val dst = destinationDirPath / name
      val src = getClass.getResourceAsStream(resourcePrefix + name)
      os.write.over(target = dst, data = src, createFolders = true)
    }
  }
}
